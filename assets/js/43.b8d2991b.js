(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{423:function(v,_,t){"use strict";t.r(_);var a=t(41),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[v._v("#")]),v._v(" 网络")]),v._v(" "),t("h2",{attrs:{id:"tcp三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[v._v("#")]),v._v(" TCP三次握手")]),v._v(" "),t("ol",[t("li",[v._v("客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）")]),v._v(" "),t("li",[v._v("服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）")]),v._v(" "),t("li",[v._v("客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）")])]),v._v(" "),t("h2",{attrs:{id:"tcp四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp四次挥手"}},[v._v("#")]),v._v(" TCP四次挥手")]),v._v(" "),t("p",[v._v("TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("TIP")]),v._v(" "),t("p",[v._v("客户端：我要关闭输入通道了。 "),t("br"),v._v("\n服务端：好的，你关闭吧，我这边也关闭这个通道。"),t("br"),v._v("\n服务端：我也要关闭输入通道了。 "),t("br"),v._v("\n客户端：好的你关闭吧，我也把这个通道关闭。")])]),v._v(" "),t("p",[v._v("挥手过程：")]),v._v(" "),t("ol",[t("li",[v._v("Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。")]),v._v(" "),t("li",[v._v("Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。")]),v._v(" "),t("li",[v._v("Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。")]),v._v(" "),t("li",[v._v("Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。")]),v._v(" "),t("li",[v._v("Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。")]),v._v(" "),t("li",[v._v("Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。")])]),v._v(" "),t("h2",{attrs:{id:"tcp和udp的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[v._v("#")]),v._v(" TCP和UDP的区别")]),v._v(" "),t("h2",{attrs:{id:"http发展历程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http发展历程"}},[v._v("#")]),v._v(" HTTP发展历程")]),v._v(" "),t("ol",[t("li",[v._v("http 0.9 负责传输html，最早的时候没有请求头和响应头")]),v._v(" "),t("li",[v._v("http 1.0 提供了http的header，根据header的不同来处理不同的资源")]),v._v(" "),t("li",[v._v("http 1.1 默认开启了keep-alive连接复用，管线化支持同一域名最多6个请求")]),v._v(" "),t("li",[v._v("http 2.0 一个域名一个tcp链接来发送数据（多路复用）,头部压缩，服务器可以预推送数据（js、css等）给客户端")]),v._v(" "),t("li",[v._v("http 3.0 解决了tcp的对头阻塞问题 QUIC协议 采用了udp")])]),v._v(" "),t("h2",{attrs:{id:"https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),t("p",[v._v("相比HTTP，HTTPS之所以更安全的是因为其在HTTP传输层之上加了一个安全层（SSL或TLS协议）；HTTPS的安全性主要体现在下面3个方面：")]),v._v(" "),t("ul",[t("li",[v._v("数据的保密性（防窃听）")]),v._v(" "),t("li",[v._v("数据的完整性（防篡改）")]),v._v(" "),t("li",[v._v("通信双方身份的真实性（防冒充）")])]),v._v(" "),t("h3",{attrs:{id:"数据的保密性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据的保密性"}},[v._v("#")]),v._v(" 数据的保密性")]),v._v(" "),t("p",[v._v("要实现数据的保密，就需要使用加密算法对数据进行加密；HTTPS的加密方案就是：")]),v._v(" "),t("ul",[t("li",[v._v("连接建立过程：")])]),v._v(" "),t("ol",[t("li",[v._v("客户端向服务器请求（发送TLS版本号、支持的加密算法、随机数C）；")]),v._v(" "),t("li",[v._v("服务器返回非对称加密的公钥（证书）、商定的加密算法、随机数S给客户端；")]),v._v(" "),t("li",[v._v("客户端验证服务器返回的证书；")]),v._v(" "),t("li",[v._v("证书验证通过，客户端就根据服务器返回的证书及随机数S和随机数C生成一个会话密钥（对称加密）；")]),v._v(" "),t("li",[v._v("客户端用服务器返回的公钥（证书）对会话密钥进行非对称加密后传输给服务器；")]),v._v(" "),t("li",[v._v("服务器通过私钥解密得到会话密钥；")]),v._v(" "),t("li",[v._v("客户端和服务器互相传输加密的握手消息来验证安全通道是否已完成；")])]),v._v(" "),t("ul",[t("li",[v._v("通信过程")])]),v._v(" "),t("ol",[t("li",[v._v("客户端使用会话密钥对传输的数据进行对称加密传输给服务器；")]),v._v(" "),t("li",[v._v("服务器使用会话密钥对传输的数据进行解密；")]),v._v(" "),t("li",[v._v("服务器使用会话密钥对响应的数据进行对称加密传输给客户端；")]),v._v(" "),t("li",[v._v("客户端使用会话密钥对传输的数据进行解密；")])]),v._v(" "),t("p",[v._v("总的来说就是：连接建立过程使用非对称加密，后续通信过程使用对称加密。")]),v._v(" "),t("h3",{attrs:{id:"数据的完整性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据的完整性"}},[v._v("#")]),v._v(" 数据的完整性")]),v._v(" "),t("p",[v._v("数据的加密，有效保证了数据不被窃听（很难得到原始的数据），但传输的数据在传输过程中有可能被篡改或替换。\n解决方案是进行数字签名：使用Hash算法将任意长度的字符串转化为固定长度的字符串，该过程不可逆，可用来作数据完整性校验；")]),v._v(" "),t("p",[v._v("数字签名的简要过程（服务器--\x3e客户端为例，客户端--\x3e服务器类似）：")]),v._v(" "),t("ol",[t("li",[v._v("服务器使用Hash算法对数据提取定长摘要")]),v._v(" "),t("li",[v._v("服务器使用私钥对摘要进行加密，作为数字签名")]),v._v(" "),t("li",[v._v("服务器将数字签名连同加密的数据一同传输给客户端")]),v._v(" "),t("li",[v._v("客户端使用公钥对数字签名进行解密，得到摘要A")]),v._v(" "),t("li",[v._v("客户端对解密后的传输数据也使用Hash算法得到定长摘要B")]),v._v(" "),t("li",[v._v("对比摘要A和摘要B，如果不一致则数据已被篡改")])]),v._v(" "),t("h3",{attrs:{id:"通信双方身份的真实性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信双方身份的真实性"}},[v._v("#")]),v._v(" 通信双方身份的真实性")]),v._v(" "),t("p",[v._v("以上加密过程，最核心的就是非对称加密的公钥和私钥；如果这个密钥都是攻击者提供的，那传输的数据在攻击者那里也是相当于裸露的；\n如何确保密钥是不被冒充的呢？HTTPS使用了数字证书(签名)，数字证书就是身份认证机构CA（Certificate Authority）加在数字身份证上的一个签名，\n证书的合法性可以向CA验证；证书的制作方法是公开的，任何人都可以自己制作证书，但只有权威的证书颁发机构的证书能通过CA认证；")]),v._v(" "),t("p",[v._v("数字证书主要包含以下信息：")]),v._v(" "),t("ul",[t("li",[v._v("证书颁发机构")]),v._v(" "),t("li",[v._v("证书颁发机构签名")]),v._v(" "),t("li",[v._v("证书绑定的服务器域名")]),v._v(" "),t("li",[v._v("证书版本、有效期")]),v._v(" "),t("li",[v._v("签名使用的加密算法（非对称算法，如RSA）")]),v._v(" "),t("li",[v._v("公钥")])]),v._v(" "),t("h3",{attrs:{id:"charles抓包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#charles抓包原理"}},[v._v("#")]),v._v(" Charles抓包原理")]),v._v(" "),t("p",[v._v("其实Charles做的就是针对HTTPS的通信双方身份的真实性进行处理；")]),v._v(" "),t("ul",[t("li",[v._v("当客户端和服务器建立连接时，Charles会拦截到服务器返回的证书（服务器公钥）")]),v._v(" "),t("li",[v._v("然后动态生成一张伪造证书（Charles公钥/假公钥）发送给客户端")]),v._v(" "),t("li",[v._v("客户端收到Charles证书后，进行验证；因为之前我们手机设置了信任，所以验证通过；（只要手机不信任这种证书，HTTPS还是能确保安全的）")]),v._v(" "),t("li",[v._v("客户端生成会话密钥，使用Charles证书对会话密钥进行加密再传输给服务器")]),v._v(" "),t("li",[v._v("Charles拦截到客户端传输的数据，使用自己的Charles私钥进行解密得到会话密钥")]),v._v(" "),t("li",[v._v("连接成功后，客户端和服务器通信，客户端对传输的数据使用会话密钥加密并使用公钥对数据摘要进行数字签名，一同传输给服务器；")]),v._v(" "),t("li",[v._v("Charles拦截到通信的数据，使用之前获得的会话密钥解密就能得到原始数据；")]),v._v(" "),t("li",[v._v("Charles同样也能篡改通信的数据：将篡改后的数据重新加密并重新生成摘要并使用之前获得的公钥进行数字签名，替换原本的签名，再传输给服务器；")]),v._v(" "),t("li",[v._v("服务器收取到数据，按正常流程解密验证；")]),v._v(" "),t("li",[v._v("服务器返回响应数据时，Charles也是类似拦截过程")])]),v._v(" "),t("h3",{attrs:{id:"防抓包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防抓包"}},[v._v("#")]),v._v(" 防抓包")]),v._v(" "),t("p",[v._v("抓包主要的原理就是中间人替换了原本的证书；防抓包就可以通过针对证书的校验来实现；")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("https不一定是安全的")]),v._v(" "),t("p",[v._v("https不一定全是安全的，一些网站会使用自签名证书。\n自签SSL证书最容易被假冒和伪造，被欺诈网站利用;部署自签SSL证书的网站，浏览器会持续弹出警告;自签SSL证书最容易受到SSL中间人攻击。")])]),v._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/f6f6a21e17c0",target:"_blank",rel:"noopener noreferrer"}},[v._v("浅谈Charles抓包原理"),t("OutboundLink")],1)])]),v._v(" "),t("h2",{attrs:{id:"http2多路复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http2多路复用"}},[v._v("#")]),v._v(" http2多路复用")]),v._v(" "),t("p",[v._v("在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：")]),v._v(" "),t("ul",[t("li",[v._v("串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）")]),v._v(" "),t("li",[v._v("连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。")])]),v._v(" "),t("p",[v._v("HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据\n流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。")]),v._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("为什么HTTP1.1不能实现多路复用")]),v._v(" "),t("p",[v._v("HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，\n所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。")])]),v._v(" "),t("h2",{attrs:{id:"jwt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[v._v("#")]),v._v(" JWT")]),v._v(" "),t("p",[v._v("Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。")]),v._v(" "),t("h3",{attrs:{id:"jwt的构成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jwt的构成"}},[v._v("#")]),v._v(" JWT的构成")]),v._v(" "),t("p",[v._v("第一部分我们称它为头部（header),第二部分我们称其为载荷（payload)，第三部分是签证（signature).")]),v._v(" "),t("h4",{attrs:{id:"header"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[v._v("#")]),v._v(" header")]),v._v(" "),t("p",[v._v("jwt的头部承载两部分信息：")]),v._v(" "),t("ul",[t("li",[v._v("声明类型，这里是jwt")]),v._v(" "),t("li",[v._v("声明加密的算法 通常直接使用HMAC或SHA256")])]),v._v(" "),t("h4",{attrs:{id:"playload"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#playload"}},[v._v("#")]),v._v(" playload")]),v._v(" "),t("p",[v._v("载荷就是存放有效信息的地方，这些有效信息包含三个部分：")]),v._v(" "),t("ul",[t("li",[v._v("标准中注册的声明")]),v._v(" "),t("li",[v._v("公共的声明")]),v._v(" "),t("li",[v._v("私有的声明")])]),v._v(" "),t("p",[t("strong",[v._v("标准中注册的声明(建议但不强制使用)")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("iss: jwt签发者")]),v._v(" "),t("li",[v._v("sub: jwt所面向的用户")]),v._v(" "),t("li",[v._v("aud: 接收jwt的一方")]),v._v(" "),t("li",[v._v("exp: jwt的过期时间，这个过期时间必须要大于签发时间")]),v._v(" "),t("li",[v._v("nbf: 定义在什么时间之前，该jwt都是不可用的.")]),v._v(" "),t("li",[v._v("iat: jwt的签发时间")]),v._v(" "),t("li",[v._v("jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。")])]),v._v(" "),t("p",[t("strong",[v._v("公共的声明")]),v._v("：\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。")]),v._v(" "),t("p",[t("strong",[v._v("公共的声明")]),v._v("：\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。")]),v._v(" "),t("h4",{attrs:{id:"signature"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#signature"}},[v._v("#")]),v._v(" signature")]),v._v(" "),t("p",[v._v("jwt的第三部分是一个签证信息，这个签证信息由三部分组成：")]),v._v(" "),t("ul",[t("li",[v._v("header (base64后的)")]),v._v(" "),t("li",[v._v("payload (base64后的)")]),v._v(" "),t("li",[v._v("secret")])]),v._v(" "),t("p",[v._v("这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。")]),v._v(" "),t("p",[v._v("将这三部分用.连接成一个完整的字符串,构成了最终的jwt。")])])}),[],!1,null,null,null);_.default=e.exports}}]);