(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{398:function(t,e,v){"use strict";v.r(e);var r=v(41),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),v("h2",{attrs:{id:"tcp三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[t._v("#")]),t._v(" TCP三次握手")]),t._v(" "),v("ol",[v("li",[t._v("客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）")]),t._v(" "),v("li",[t._v("服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）")]),t._v(" "),v("li",[t._v("客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）")])]),t._v(" "),v("h2",{attrs:{id:"tcp四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp四次挥手"}},[t._v("#")]),t._v(" TCP四次挥手")]),t._v(" "),v("p",[t._v("TCP是全双工信道，何为全双工就是客户端与服务端建立两条通道，通道1:客户端的输出连接服务端的输入；通道2:客户端的输入连接服务端的输出。两个通道可以同时工作：客户端向服务端发送信号的同时服务端也可以向客户端发送信号。所以关闭双通道的时候就是这样：")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("客户端：我要关闭输入通道了。 "),v("br"),t._v("\n服务端：好的，你关闭吧，我这边也关闭这个通道。"),v("br"),t._v("\n服务端：我也要关闭输入通道了。 "),v("br"),t._v("\n客户端：好的你关闭吧，我也把这个通道关闭。")])]),t._v(" "),v("p",[t._v("挥手过程：")]),t._v(" "),v("ol",[v("li",[t._v("Client向Server发送FIN包，表示Client主动要关闭连接，然后进入FIN_WAIT_1状态，等待Server返回ACK包。此后Client不能再向Server发送数据，但能读取数据。")]),t._v(" "),v("li",[t._v("Server收到FIN包后向Client发送ACK包，然后进入CLOSE_WAIT状态，此后Server不能再读取数据，但可以继续向Client发送数据。")]),t._v(" "),v("li",[t._v("Client收到Server返回的ACK包后进入FIN_WAIT_2状态，等待Server发送FIN包。")]),t._v(" "),v("li",[t._v("Server完成数据的发送后，将FIN包发送给Client，然后进入LAST_ACK状态，等待Client返回ACK包，此后Server既不能读取数据，也不能发送数据。")]),t._v(" "),v("li",[t._v("Client收到FIN包后向Server发送ACK包，然后进入TIME_WAIT状态，接着等待足够长的时间（2MSL）以确保Server接收到ACK包，最后回到CLOSED状态，释放网络资源。")]),t._v(" "),v("li",[t._v("Server收到Client返回的ACK包后便回到CLOSED状态，释放网络资源。")])]),t._v(" "),v("h2",{attrs:{id:"https握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https握手过程"}},[t._v("#")]),t._v(" HTTPS握手过程")]),t._v(" "),v("ol",[v("li",[t._v("客户端使用https的url访问web服务器,要求与服务器建立ssl连接")]),t._v(" "),v("li",[t._v("web服务器收到客户端请求后, 确认加密通信协议版本是否一致，如果版本一致则返回服务器证书，否则关闭加密通信")]),t._v(" "),v("li",[t._v("客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥，客户端利用公钥将会话秘钥加密, 并传送给服务端")]),t._v(" "),v("li",[t._v("服务端利用自己的私钥解密出会话秘钥，之后服务器与客户端使用秘钥加密传输")])]),t._v(" "),v("h2",{attrs:{id:"http2多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http2多路复用"}},[t._v("#")]),t._v(" http2多路复用")]),t._v(" "),v("p",[t._v("在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：")]),t._v(" "),v("ul",[v("li",[t._v("串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）")]),t._v(" "),v("li",[t._v("连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。")])]),t._v(" "),v("p",[t._v("HTTP/2的多路复用就是为了解决上述的两个性能问题。 在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据\n流。 多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("为什么HTTP1.1不能实现多路复用")]),t._v(" "),v("p",[t._v("HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，\n所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。")])])])}),[],!1,null,null,null);e.default=_.exports}}]);