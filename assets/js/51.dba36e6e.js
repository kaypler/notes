(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{435:function(e,t,r){"use strict";r.r(t);var n=r(41),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"vue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),r("h2",{attrs:{id:"从new一个vue对象开始"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从new一个vue对象开始"}},[e._v("#")]),e._v(" 从new一个Vue对象开始")]),e._v(" "),r("p",[r("strong",[e._v("初始化")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("初始化生命周期、事件、 render")]),e._v(" "),r("li",[e._v("调用 beforeCreate 钩子函数")]),e._v(" "),r("li",[e._v('初始化 props、methods、data、computed 与 watch ，并且对 options 中的数据进行"响应式化"（双向绑定）以及完成依赖收集')]),e._v(" "),r("li",[e._v("调用 created 钩子函数")]),e._v(" "),r("li",[e._v("挂载组件")])]),e._v(" "),r("p",[r("strong",[e._v("模板编译")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("parse 解析阶段。用正则等方式解析 template 中的指令、class、style等数据，形成 ast 。")]),e._v(" "),r("li",[e._v("optimize 优化阶段。标记 static 静态节点。在新旧节点比较变更时，diff 算法会直接跳过静态节点，这里优化了 patch 的性能。")]),e._v(" "),r("li",[e._v("generate 代码生成阶段。将 ast 转化成 render function 字符串，得到结果是 render 的字符串以及 staticRenderFns 字符串。")])]),e._v(" "),r("p",[r("strong",[e._v("patch")]),e._v("：")]),e._v(" "),r("ul",[r("li",[e._v("如果新旧 VNode 都是静态的，同时它们的 key 相同（代表同一节点），并且新的 VNode 是 clone 或者是标记了 once （标记 v-once 属性，只渲染一次），那么只需要替换 elm 以及 componentInstance 即可。")]),e._v(" "),r("li",[e._v("新老节点均有 children 子节点，则对子节点进行 diff 操作，调用 updateChildren 方法。")]),e._v(" "),r("li",[e._v("如果老节点没有子节点而新节点存在子节点，先清空老节点 DOM 的文本内容，然后为当前 DOM 节点加入子节点。")]),e._v(" "),r("li",[e._v("当新节点没有子节点而老节点有子节点的时候，则移除该 DOM 节点的所有子节点。")]),e._v(" "),r("li",[e._v("当新老节点都无子节点的时候，只是文本的替换。")])]),e._v(" "),r("p",[r("strong",[e._v("diff")]),e._v(":\n"),r("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1006029",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"异步更新队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[e._v("#")]),e._v(" 异步更新队列")]),e._v(" "),r("p",[e._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。\n然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、\nMutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。")])])}),[],!1,null,null,null);t.default=v.exports}}]);