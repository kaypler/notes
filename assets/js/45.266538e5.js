(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{423:function(t,e,v){"use strict";v.r(e);var s=v(41),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"css"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[t._v("#")]),t._v(" CSS")]),t._v(" "),v("h2",{attrs:{id:"css的优先级"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css的优先级"}},[t._v("#")]),t._v(" CSS的优先级")]),t._v(" "),v("p",[t._v("优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。\n而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。\n当同一个元素有多个声明的时候，优先级才会有意义。因为每一个直接作用于元素的 CSS 规则总是会接管/覆盖（take over）该元素从祖先元素继承而来的规则。")]),t._v(" "),v("p",[t._v("下面列表中，选择器类型的优先级是递增的：")]),t._v(" "),v("ol",[v("li",[t._v("类型选择器（例如，h1）和伪元素（例如，::before）")]),t._v(" "),v("li",[t._v('类选择器 (例如，.example)，属性选择器（例如，[type="radio"]）和伪类（例如，:hover）')]),t._v(" "),v("li",[t._v("ID 选择器（例如，#example）。")])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),v("p",[t._v("通配选择符（universal selector）（*）关系选择符（combinators）（+, >, ~, ' ', ||）和 否定伪类（negation pseudo-class）（:not()）对优先级没有影响。\n（但是，在 :not() 内部声明的选择器会影响优先级）。")])]),t._v(" "),v("p",[t._v("给元素添加的"),v("strong",[t._v("内联样式")]),t._v(' (例如，style="font-weight:bold") 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。')]),t._v(" "),v("h2",{attrs:{id:"viewport"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#viewport"}},[t._v("#")]),t._v(" viewport")]),t._v(" "),v("p",[t._v("视口( viewport)代表当前可见的计算机图形区域。在 Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI， 菜单栏等——即指你正在浏览的文档的那一部分。")]),t._v(" "),v("p",[t._v("一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("布局视口( layout viewport)")]),t._v("：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。\n所以，布局视口是网页布局的基准窗口，在 PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括 borders 、 margins、滚动条）。\n在移动端，布局视口被赋予一个默认值，大部分为 980px，这保证 PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。\n我们可以通过调用 "),v("code",[t._v("document.documentElement.clientWidth/clientHeight")]),t._v("来获取布局视口大小。")]),t._v(" "),v("li",[v("strong",[t._v("视觉视口( visual viewport)")]),t._v("：用户通过屏幕真实看到的区域。视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。\n当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。\n例如：用户将浏览器窗口放大了 200%，这时浏览器窗口中的 CSS像素会随着视觉视口的放大而放大，这时一个 CSS像素会跨越更多的物理像素。\n所以，布局视口会限制你的 CSS布局而视觉视口决定用户具体能看到什么。我们可以通过调用 "),v("code",[t._v("window.innerWidth/innerHeight")]),t._v("来获取视觉视口大小。")]),t._v(" "),v("li",[v("strong",[t._v("理想视口( ideal viewport)")]),t._v("：布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口就诞生了：网站页面在移动端展示的理想大小。\n在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。\n上面在介绍 CSS像素时曾经提到 "),v("code",[t._v("页面的缩放系数=CSS像素/设备独立像素")]),t._v("，实际上说 "),v("code",[t._v("页面的缩放系数=理想视口宽度/视觉视口宽度")]),t._v("更为准确。\n所以，当页面缩放比例为 100%时， CSS像素=设备独立像素， 理想视口=视觉视口。\n我们可以通过调用 "),v("code",[t._v("screen.width/height")]),t._v("来获取理想视口大小。")])]),t._v(" "),v("h3",{attrs:{id:"meta-viewport"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#meta-viewport"}},[t._v("#")]),t._v(" Meta viewport")]),t._v(" "),v("p",[v("code",[t._v("<meta>")]),t._v("元素表示那些不能由其它 HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。\n我们可以借助 ")]),v("meta"),t._v("元素的 viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。"),v("p"),t._v(" "),v("div",{staticClass:"language-html line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-html"}},[v("code",[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token tag"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("name")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("viewport"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),v("span",{pre:!0,attrs:{class:"token attr-value"}},[v("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[t._v("为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。\n"),v("code",[t._v("device-width")]),t._v("就等于理想视口的宽度，所以设置 "),v("code",[t._v("width=device-width")]),t._v("就相当于让布局视口等于理想视口。\n由于 "),v("code",[t._v("initial-scale=理想视口宽度/视觉视口宽度")]),t._v("，所以我们设置 "),v("code",[t._v("initial-scale=1")]),t._v(";就相当于让视觉视口等于理想视口。\n这时，1个 CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。")]),t._v(" "),v("p",[t._v("上面提到 "),v("code",[t._v("width")]),t._v("可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置 "),v("code",[t._v("initial-scale")]),t._v("也有肯能影响到布局视口，因为布局视口宽度取的是"),v("strong",[t._v("width和视觉视口宽度的最大值")]),t._v("。\n例如：若手机的理想视口宽度为 400px，设置 "),v("code",[t._v("width=device-width")]),t._v("， "),v("code",[t._v("initial-scale=2")]),t._v("，此时 "),v("code",[t._v("视觉视口宽度=理想视口宽度/initial-scale")]),t._v("即 200px，布局视口取两者最大值即 device-width 400px。\n若设置 width=device-width， initial-scale=0.5，此时 视觉视口宽度=理想视口宽度/initial-scale即 800px，布局视口取两者最大值即 800px。")]),t._v(" "),v("h3",{attrs:{id:"一些术语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一些术语"}},[t._v("#")]),t._v(" 一些术语")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("英寸")]),t._v(": 一般用英寸描述屏幕的物理大小(屏幕对角线的长度)，英寸("),v("code",[t._v("inch")]),t._v(",缩写为 "),v("code",[t._v("in")]),t._v(")在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。"),v("code",[t._v("1英寸=2.54厘米")])]),t._v(" "),v("li",[v("strong",[t._v("像素")]),t._v(": 像素即一个小方块，它具有特定的位置和颜色。")]),t._v(" "),v("li",[v("strong",[t._v("屏幕分辨率")]),t._v(": 指一个屏幕具体由多少个像素点组成。")])]),t._v(" "),v("h3",{attrs:{id:"ppi"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ppi"}},[t._v("#")]),t._v(" PPI")]),t._v(" "),v("p",[t._v("PPI(Pixel Per Inch)：每英寸包括的像素数。PPI可以用于描述屏幕的清晰度以及一张图片的质量。"),v("br"),t._v("\n计算公式：sqrt(水平像素点数^2+垂直像素点数^2)/尺寸")]),t._v(" "),v("h3",{attrs:{id:"dpi"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dpi"}},[t._v("#")]),t._v(" DPI")]),t._v(" "),v("p",[t._v("DPI(Dot Per Inch)：即每英寸包括的点数。\n这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。\n平时你可能会看到使用 DPI来描述图片和屏幕，这时的 DPI应该和 PPI是等价的， DPI最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。")]),t._v(" "),v("h3",{attrs:{id:"dip"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dip"}},[t._v("#")]),t._v(" DIP")]),t._v(" "),v("p",[t._v("设备独立像素( Device Independent Pixels)简称 DIP或 DP。在实际开发中使用的CSS中的像素就是设备独立像素中的一种，CSS像素的单位为px。\n这个单位是用来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少。\n例如黑色手机使用了视网膜屏幕的技术，假如列表的宽度为 300个像素，那么在一条水平线上，\n白色手机会用 300个物理像素去渲染它，而黑色手机实际上会用 600个物理像素去渲染它。")]),t._v(" "),v("h3",{attrs:{id:"dpr"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dpr"}},[t._v("#")]),t._v(" DPR")]),t._v(" "),v("p",[t._v("设备像素比 device pixel ratio简称 dpr，即物理像素和设备独立像素的比值。\n在 web中，浏览器为我们提供了"),v("code",[t._v("window.devicePixelRatio")]),t._v("来帮助我们获取 dpr。\n在 css中，可以使用媒体查询"),v("code",[t._v("min-device-pixel-ratio")]),t._v("，区分 dpr：")]),t._v(" "),v("div",{staticClass:"language-css line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-css"}},[v("code",[v("span",{pre:!0,attrs:{class:"token atrule"}},[v("span",{pre:!0,attrs:{class:"token rule"}},[t._v("@media")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token property"}},[t._v("-webkit-min-device-pixel-ratio")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token property"}},[t._v("min-device-pixel-ratio")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("2"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("blockquote",[v("p",[t._v("在写 CSS时，我们用到最多的单位是 px，即 CSS像素，当页面缩放比例为 100%时，一个 CSS像素等于一个设备独立像素。\n但是 CSS像素是很容易被改变的，当用户对浏览器进行了放大， CSS像素会被放大，这时一个 CSS像素会跨越更多的物理像素。\n页面的缩放系数=CSS像素/设备独立像素。")])]),t._v(" "),v("h3",{attrs:{id:"获取浏览器大小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#获取浏览器大小"}},[t._v("#")]),t._v(" 获取浏览器大小")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("window.innerHeight")]),t._v("：获取浏览器视觉视口高度（包括垂直滚动条）。")]),t._v(" "),v("li",[v("strong",[t._v("window.outerHeight")]),t._v("：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。")]),t._v(" "),v("li",[v("strong",[t._v("window.screen.Height")]),t._v("：获取获屏幕取理想视口高度，这个数值是固定的， 设备的分辨率/设备像素比")]),t._v(" "),v("li",[v("strong",[t._v("window.screen.availHeight")]),t._v("：浏览器窗口可用的高度。")]),t._v(" "),v("li",[v("strong",[t._v("document.documentElement.clientHeight")]),t._v("：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。")]),t._v(" "),v("li",[v("strong",[t._v("document.documentElement.offsetHeight")]),t._v("：包括内边距、滚动条、边框和外边距。")]),t._v(" "),v("li",[v("strong",[t._v("document.documentElement.scrollHeight")]),t._v("：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。")])]),t._v(" "),v("h3",{attrs:{id:"获取元素大小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#获取元素大小"}},[t._v("#")]),t._v(" 获取元素大小")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("clientHeight")]),t._v("：包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。")]),t._v(" "),v("li",[v("strong",[t._v("offsetHeight")]),t._v("：包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。")]),t._v(" "),v("li",[v("strong",[t._v("scrollHeight")]),t._v("：包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight")]),t._v(" "),v("li",[v("strong",[t._v("scrollTop")]),t._v("：代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。")]),t._v(" "),v("li",[v("strong",[t._v("offsetTop")]),t._v("：当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素。")])]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("offsetHeight与style.height区别")]),t._v(" "),v("ol",[v("li",[t._v("offsetHeight可以获取写在样式文件里的属性值，而style.height只能获取行内属性，在表现与结构分离的今天，这显然是不合适的")]),t._v(" "),v("li",[t._v("offsetHeight返回的是一个数值，而style.height返回的是一个字符串，单位是“px”")]),t._v(" "),v("li",[t._v("offsetHeight是只读，而style.height是可读写")]),t._v(" "),v("li",[t._v("如果没有为元素设置高度，offsetHeight会根据内容获取高度值，而style.height会返回undefind")])])]),t._v(" "),v("h2",{attrs:{id:"移动端适配方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#移动端适配方案"}},[t._v("#")]),t._v(" 移动端适配方案")]),t._v(" "),v("h3",{attrs:{id:"_1-flexible方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-flexible方案"}},[t._v("#")]),t._v(" 1.flexible方案")]),t._v(" "),v("p",[t._v("flexible方案是阿里早期开源的一个移动端适配解决方案，引用 flexible后，我们在页面上统一使用"),v("code",[t._v("rem")]),t._v("来布局。\n"),v("code",[t._v("rem")]),t._v("是相对于"),v("code",[t._v("html")]),t._v("节点的"),v("code",[t._v("font-size")]),t._v("来做计算的。")]),t._v(" "),v("p",[t._v("将 "),v("code",[t._v("html")]),t._v("节点的 "),v("code",[t._v("font-size")]),t._v("设置为页面 "),v("code",[t._v("clientWidth")]),t._v("(布局视口)的 1/10，即 1rem就等于页面布局视口的 1/10，\n这就意味着我们后面使用的 rem都是按照页面比例来计算的。")]),t._v(" "),v("p",[t._v("以 iPhone6为例：布局视口为 375px，则 "),v("code",[t._v("1rem=37.5px")]),t._v("，这时 UI给定一个元素的宽为 75px（设备独立像素），我们只需要将它设置为 "),v("code",[t._v("75/37.5=2rem")]),t._v("。")]),t._v(" "),v("p",[t._v("当然，每个布局都要计算非常繁琐，我们可以借助 "),v("code",[t._v("PostCSS")]),t._v("的 "),v("code",[t._v("px2rem")]),t._v("插件来帮助我们完成这个过程。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("lexible方案的缺陷")]),t._v(" "),v("ol",[v("li",[t._v("lib-flexible在适配的时候会修改viewport的initial-scale，导致viewport的width不等于device-width，导致媒介查询不可用。")]),t._v(" "),v("li",[t._v("lib-flexible现在只适配了iphone设备，安卓设备压根没适配。")])])]),t._v(" "),v("h3",{attrs:{id:"vh、vw方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vh、vw方案"}},[t._v("#")]),t._v(" vh、vw方案")]),t._v(" "),v("p",[t._v("vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。")]),t._v(" "),v("p",[t._v("如果视觉视口为 "),v("code",[t._v("375px")]),t._v("，那么 "),v("code",[t._v("1vw=3.75px")]),t._v("，这时 UI给定一个元素的宽为 "),v("code",[t._v("75px")]),t._v("（设备独立像素），我们只需要将它设置为 "),v("code",[t._v("75/3.75=20vw")]),t._v("。")]),t._v(" "),v("p",[t._v("这里的比例关系我们也不用自己换算，我们可以使用 "),v("code",[t._v("PostCSS")]),t._v("的 "),v("code",[t._v("postcss-px-to-viewport")]),t._v(" 插件帮我们完成这个过程。写代码时，我们只需要根据 UI给的设计图写 px单位即可。")]),t._v(" "),v("p",[t._v("当然，没有一种方案是十全十美的， vw同样有一定的缺陷：")]),t._v(" "),v("ul",[v("li",[t._v("px转换成 vw不一定能完全整除，因此有一定的像素差。")]),t._v(" "),v("li",[t._v("比如当容器使用 vw， margin采用 px时，很容易造成整体宽度超过 100vw，从而影响布局效果。当然我们也是可以避免的，例如使用 padding代替 margin，结合 calc()函数使用等等...")])]),t._v(" "),v("h2",{attrs:{id:"图片模糊问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图片模糊问题"}},[t._v("#")]),t._v(" 图片模糊问题")]),t._v(" "),v("p",[t._v("我们平时使用的图片大多数都属于位图（ png、jpg...），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值。\n理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。\n而在 dpr>1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在 dpr>1的屏幕上就会模糊。")]),t._v(" "),v("p",[v("strong",[t._v("解决方案")]),t._v("：")]),t._v(" "),v("ol",[v("li",[t._v("使用"),v("code",[t._v("media")]),t._v("查询判断不同的设备像素比来显示不同精度的图片")]),t._v(" "),v("li",[t._v("使用 "),v("code",[t._v("img")]),t._v("标签的 "),v("code",[t._v("srcset")]),t._v("属性，浏览器会自动根据像素密度匹配最佳显示图片")])])])}),[],!1,null,null,null);e.default=a.exports}}]);